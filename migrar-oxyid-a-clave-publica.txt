Guía paso a paso: Construyendo la aplicación Oxy
Auth (Expo 54 + Node.js + MongoDB)
Introducción
Oxy Auth es una aplicación móvil diseñada para dar a los usuarios control soberano sobre su identidad
digital y sus datos personales. Esto se logra mediante la generación de una identidad criptográfica única en
el dispositivo del usuario (un par de claves pública/privada) y el uso de firmas digitales para autenticar
acciones. A continuación, presentamos una guía técnica paso a paso para implementar Oxy Auth utilizando
Expo SDK 54 (framework React Native), un backend con Node.js y una base de datos MongoDB.
En esta guía aprenderás a:
- Generar y almacenar de forma segura una identidad única en el dispositivo (clave pública y privada), de
manera auto-custodiada (similar a cómo funciona Bitcoin con sus claves privadas) 1 .
- Utilizar la clave privada para firmar datos o mensajes, permitiendo verificar la autenticidad del usuario
mediante la clave pública correspondiente 2 .
- Diseñar un esquema de datos de perfil del usuario (nombre, fecha de nacimiento, historial/biografía,
listas de seguidores y seguidos) almacenados en MongoDB de forma realista pero segura.
- Implementar el backend Node.js con rutas para actualizar y recuperar información, incluyendo un
ejemplo de código para actualizar el nombre de usuario en la base de datos.
- Integrar mecanismos de redundancia y recuperación de datos: usar MongoDB como base de datos
central y considerar el uso de IPFS (InterPlanetary File System) para respaldar datos importantes,
explicando cómo integrarlo y cómo reindexar o restaurar perfiles si el backend pierde información.
- Explicar la separación de responsabilidades entre frontend y backend, qué bibliotecas criptográficas usar
en cada caso (por ejemplo, Node crypto en el backend, o librerías JavaScript como crypto-js /Expo
Crypto en el frontend)

3

, y cómo verificar firmas de otros usuarios de manera segura.

Sigue estos pasos para construir Oxy Auth, entendiendo cada concepto clave en el camino. Nota: Esta guía
asume familiaridad básica con JavaScript/TypeScript, pero introduce conceptos de seguridad,
descentralización y sincronización de datos desde cero, pensando en lectores sin experiencia previa en
identidad distribuida o blockchain.

1. Generación de una Identidad Única en el Dispositivo (Expo 54)
Concepto: En lugar de un nombre de usuario/contraseña tradicional, Oxy Auth usa criptografía de clave
pública para la identidad. Cada usuario tendrá un par clave privada / clave pública generado localmente
en su teléfono. La clave privada actúa como identidad secreta (similar a una semilla o “llave maestra”), y la
clave pública es un identificador que puede compartirse y que otros pueden usar para verificar tu
autenticidad. Esto es análogo a Bitcoin, donde cada usuario controla sus fondos mediante claves privadas, y
las transacciones se firman digitalmente 1 . Aquí, en lugar de controlar dinero, la clave privada controlará
tu identidad y datos en la app.

1

Generación de claves en React Native: Expo (React Native) no incluye por defecto la API crypto de
Node.js, así que debemos usar bibliotecas JavaScript o utilidades nativas para generar las claves. Una
opción popular es usar una librería de criptografía de curvas elípticas como elliptic (pure JS), que soporta el
algoritmo ECDSA con la curva secp256k1 (usada en Bitcoin) 1 . Alternativamente, podrías usar reactnative-crypto o tweetnacl (para Ed25519) según tus necesidades, pero aquí usaremos elliptic para imitar
el enfoque “como en Bitcoin”.
1. Instalar dependencia criptográfica: En Expo, puedes añadir la librería elliptic a tu proyecto
(es pura JS, no requiere enlace nativo). Ejecuta: npm install elliptic . También instalaremos
expo-random para obtener bytes aleatorios seguros.
2. Generar el par de claves: Utiliza elliptic para crear un objeto de curva elíptica y genera un
keypair. Por ejemplo:
import * as Random from 'expo-random';
import { ec as EC } from 'elliptic';
// Inicializar curva elíptica secp256k1
const ec = new EC('secp256k1');
// Generar 32 bytes aleatorios para la clave privada
const randomBytes = Random.getRandomBytes(32);
const privateKeyHex = Buffer.from(randomBytes).toString('hex');
// Crear par de claves usando la clave privada aleatoria
const keyPair = ec.keyFromPrivate(privateKeyHex);
const publicKeyHex = keyPair.getPublic('hex');
console.log("Clave privada:", privateKeyHex);
console.log("Clave pública:", publicKeyHex);
En este código, generamos 32 bytes aleatorios (256 bits) para formar una clave privada y luego obtenemos
la clave pública correspondiente. La librería elliptic ofrece métodos convenientes como genKeyPair()
para hacerlo directamente

4

. Por ejemplo:

const keyPair = ec.genKeyPair();
// Obtener las claves en formato hexadecimal
const privateKeyHex = keyPair.getPrivate('hex');
const publicKeyHex = keyPair.getPublic('hex');
Este método genKeyPair() nos devuelve un objeto con ambas claves

5

. Importante: Nunca imprimas

ni expongas la clave privada en un entorno real, aquí se muestra solo con fines ilustrativos. La clave privada
debe tratarse con el mismo nivel de secreto que una contraseña o datos financieros sensibles 6 .
1. Almacenamiento seguro de la clave privada: Una vez generada, la clave privada no debe salir del
dispositivo. No la envíes al servidor ni la muestres en interfaz. En Expo/React Native, una forma de

2

guardarla de manera segura es usar SecureStore de Expo, que almacena datos de forma cifrada en
el dispositivo 7 . Por ejemplo:
import * as SecureStore from 'expo-secure-store';
await SecureStore.setItemAsync('userPrivateKey', privateKeyHex);
SecureStore se encarga de cifrar y almacenar la clave localmente 7 . Así, aunque la app se cierre, la clave
permanecerá en el dispositivo para futuras sesiones, protegida contra accesos externos. La clave pública,
en cambio, no es sensible: podemos guardarla en SecureStore también o recalcularla a partir de la privada
cuando se necesite (ya que, dado el privado, se puede derivar el público de forma determinística 8 ).
Incluso podríamos enviarla al servidor para registrar al usuario, como veremos más adelante.
Resumen de este paso: En el primer arranque de la app, generamos un par de claves pública/privada en el
dispositivo. La clave privada se almacena localmente de forma segura (por ejemplo, en SecureStore) y
nunca se comparte. La clave pública actúa como identificador público del usuario (similar a un nombre de
usuario, pero criptográficamente vinculado a su identidad). Con esto, hemos establecido una identidad
única auto-custodiada para el usuario.

2. Firma Digital de Datos o Mensajes (Autenticación del Usuario)
Con la clave privada disponible solo en el dispositivo, podemos firmar digitalmente datos o mensajes.
¿Qué significa esto? Una firma digital es un pedazo de datos generado matemáticamente usando la clave
privada, de tal forma que cualquiera con la clave pública pueda verificar su autenticidad. En palabras
sencillas: sólo el poseedor de la clave privada pudo haber creado esa firma, por lo que es una prueba de
identidad. Esto es exactamente lo que sucede en sistemas como blockchain: alguien firma un mensaje con
su clave privada y otros verifican con la pública que realmente provino de esa persona 2 .
¿Por qué firmar? Para Oxy Auth, las firmas garantizan que las acciones realizadas en la app (actualizar el
perfil, enviar un mensaje, seguir a alguien, etc.) fueron autorizadas por el usuario legítimo. Incluso si
alguien intentara falsificar una petición al servidor, no podría generar una firma válida sin la clave privada
del usuario. Además, las firmas aseguran la integridad del dato: si un mensaje firmado es modificado
aunque sea un poco, la firma dejará de ser válida al verificarla.
Algoritmo de firma: Usaremos ECDSA (algoritmo de firma con curvas elípticas) con la curva secp256k1
para consistencia con la clave generada. ECDSA es eficiente y seguro para firmas digitales, preferido en
muchos sistemas modernos frente a RSA debido a tamaños de clave más pequeños para un nivel de
seguridad equivalente 9 . Cabe destacar que ECDSA (y en general las firmas digitales) no cifran datos,
solo sirven para autenticidad e integridad 10 (no confundir con cifrado público/privado; aquí no
escondemos el contenido, solo probamos quién lo envió).
Firmar en el frontend (Expo): Podemos reutilizar el objeto keyPair de elliptic para firmar. La librería
elliptic nos proporciona un método sign() que, dado un hash de mensaje, devuelve la firma. Es
recomendable hashear el mensaje antes de firmarlo (usando SHA-256, por ejemplo), ya que ECDSA firma
un hash de tamaño fijo. Expo ofrece expo-crypto para calcular hashes de forma equivalente a Node 3 .
Por ejemplo:

3

import * as Crypto from 'expo-crypto';
// Mensaje a firmar (por ejemplo, concatenación de campos o un JSON
stringificado)
const message = "Nombre=Alice;Operacion=ActualizarPerfil";
// 1. Calcular hash SHA-256 del mensaje
const messageHash = await Crypto.digestStringAsync(
Crypto.CryptoDigestAlgorithm.SHA256,
message
);
// 2. Firmar el hash con la clave privada usando elliptic
const signatureObj = keyPair.sign(messageHash);
// Convertir la firma a formato hex (DER codificado)
const signatureHex = signatureObj.toDER('hex');
console.log("Firma digital:", signatureHex);
En este fragmento, signatureHex contendrá la firma digital del mensaje. Internamente, la firma ECDSA
consiste en un par de valores (generalmente llamados r y s). Aquí usamos toDER('hex') para obtener la
representación estándar en hexadecimal.
Verificación (concepto): La contraparte de firmar es verificar. Cualquier receptor (ya sea el backend o otro
usuario) que tenga tu clave pública puede tomar el mensaje original, la firma y tu clave pública, y ejecutar
un algoritmo de verificación. Si la firma es auténtica y el mensaje no fue alterado, la verificación resultará
verdadera. Matemáticamente, la verificación con ECDSA asegura que la firma fue generada con la clave
privada correspondiente a esa clave pública 11 . Veremos más sobre verificación de firmas en el paso 5,
pero ten presente que cada firma es válida solo para ese mensaje específico; si los datos cambian, la firma
ya no coincidirá.
¿Cuándo firmar en Oxy Auth? Algunos casos prácticos:
- Registro/Inicio de sesión: En lugar de enviar una contraseña al servidor, el cliente podría firmar un nonce
(un número aleatorio) proporcionado por el servidor para comprobar identidad. El servidor verifica con la
clave pública (registrada durante el alta) y así autentica al usuario sin transmitir credenciales sensibles.
- Actualización de perfil u operaciones sensibles: Cada petición al backend podría incluir un campo
signature generado a partir de los datos enviados. El backend verificará esa firma usando la clave
pública del usuario almacenada, asegurando que la petición no fue alterada en tránsito y que proviene
realmente del usuario.
- Mensajería o interacciones P2P: Si usuarios intercambian datos directamente (o a través del server),
pueden firmarlos para que el receptor esté seguro de la autoría.
Tip de seguridad: La clave privada nunca sale del dispositivo, por lo que todas las firmas se generan en el
frontend. El backend solo necesita la clave pública para verificar. Esto maximiza la privacidad y seguridad del
usuario, alineado con la filosofía de auto-custodia: aunque el servidor almacene tu perfil, no puede
suplantarte sin tu clave privada. En resumen, con este paso hemos habilitado la autenticación

4

criptográfica: el usuario demuestra quién es firmando datos, y cualquiera (con su clave pública) puede
verificar esa prueba.

3. Backend Node.js: Modelo de Datos de Usuario en MongoDB
Ahora pasemos al lado del backend, donde utilizaremos Node.js para crear una API (por ejemplo, con
Express) y MongoDB para almacenar los datos. El backend será responsable de: registrar nuevos usuarios
(almacenando su clave pública y perfil inicial), guardar actualizaciones de perfil, gestionar la lista de
seguidores/seguidos, y proveer endpoints para consultar esta información.
Diseño de la colección de usuarios: Crearemos una colección MongoDB (llamada, por ejemplo, users )
donde cada documento representa a un usuario de Oxy Auth. A continuación, definimos qué campos incluir
de forma realista pero segura:
• publicKey : Clave pública del usuario (formato hex o base64). Este será el identificador único del
usuario en el sistema. Podemos usarla como _id en MongoDB por unicidad, o como un campo
con índice único. Todas las firmas se verificarán contra esta clave.
• name : nombre del usuario (ej. "Alice").
• birthDate : fecha de nacimiento (ej. "1990-05-15").
• bio o history : un texto breve de perfil o historial del usuario.
• followers : lista de claves públicas (o IDs) de usuarios que siguen a este usuario. Podría ser un
array de publicKey de otros usuarios.
• following : lista de claves públicas de usuarios a los que este usuario sigue.
Estos campos cubrirían lo solicitado (nombre, fecha de nacimiento, historial, seguidores y seguidos).
Puedes extender el esquema con otros campos (foto de perfil, últimas actualizaciones, etc.) según la
necesidad.
Consideraciones de seguridad de los datos:
- Datos personales: Campos como fecha de nacimiento son sensibles. Si bien los almacenamos en texto
plano en la BD para esta versión (porque probablemente se mostrarán en el perfil), debes asegurarte de
proteger la base de datos con autenticación y conexiones seguras. En un nivel más avanzado, podrías cifrar
ciertos campos en la BD para que ni siquiera el administrador del sistema pueda leerlos sin la autorización
del usuario, pero eso complica la búsqueda y está fuera del alcance inicial.
- Integridad: Dado que podemos usar firmas, el servidor puede opcionalmente guardar junto a ciertos
datos una firma del usuario. Por ejemplo, podríamos guardar nameSignature que sea la firma del
nombre por parte del usuario, de modo que cualquier cambio de nombre va acompañado de una firma
nueva. Así, otro servicio o auditor podría verificar que efectivamente el usuario autorizó ese cambio. Esto es
opcional pero refuerza la confianza en los datos.
- Seguidores/seguidos: Estas listas pueden crecer, así que podrías almacenarlas como subdocumentos o en
una colección aparte (ej: follows con documentos { follower: X, following: Y }). Para simplificar,
asumiremos arrays dentro del documento de usuario, actualizables con operadores de Mongo.
- No almacenar privada: Reiteramos, nunca almacenes la clave privada en el backend. Solo la pública y los
datos de perfil. La autenticación se basa en firmas, no en secretos almacenados en el servidor.
Registro de usuario (alta): Cuando un usuario instala la app y genera sus claves, necesitaremos crear su
perfil en la base de datos. Un posible flujo: el app envía al backend una petición de registro con

5

publicKey y los datos de perfil (nombre, etc.), posiblemente firmados. El backend verifica la firma para
asegurarse que proviene del dueño de esa clave pública, luego guarda al usuario. Si no verificamos en
registro, al menos almacenamos la publicKey proporcionada. Esa clave pública se convierte en la
identidad del usuario en el sistema central.
Implementación en Node.js (ejemplo usando Express y Driver de MongoDB):
• Conecta a MongoDB usando el driver oficial o Mongoose. Por simplicidad, usemos el driver nativo.
Supongamos que ya tienes un cliente conectado a la base de datos y una referencia a la colección
users (ej. const usersCollection = db.collection('users') ).
• Crea una ruta para actualizar datos del usuario, por ejemplo el nombre (como pidieron). Esta ruta
esperará recibir la publicKey del usuario (o derivarla de su sesión/token) y el nuevo name a
asignar, junto con una firma de esta actualización.
Ejemplo de código para una ruta Express que actualiza el nombre:

// Supongamos que req.body contiene { publicKey, newName, signature }
app.put('/user/name', async (req, res) => {
const { publicKey, newName, signature } = req.body;
if (!publicKey || !newName || !signature) {
return res.status(400).send("Datos incompletos");
}
// (Paso opcional pero recomendado: verificar la firma
// para asegurarnos de que el propietario autorizó el cambio)
const message = `name:${newName}`;
const isValid = verifySignature(publicKey, message, signature);
if (!isValid) {
return res.status(401).send("Firma inválida. No autorizado.");
}
try {
// Construir el filtro de búsqueda y la actualización
const filter = { publicKey: publicKey };
const update = { $set: { name: newName } };
const result = await usersCollection.updateOne(filter, update);
if (result.matchedCount === 0) {
return res.status(404).send("Usuario no encontrado");
}
res.send("Nombre actualizado correctamente");
} catch (err) {
console.error(err);
res.status(500).send("Error del servidor al actualizar nombre");
}
});

6

En el código anterior,

verifySignature

sería una función que utiliza la funcionalidad de Node

( crypto ) o una librería como elliptic para verificar la firma (veremos más en la sección 5 sobre cómo
hacerlo). Lo esencial es la línea de actualización en MongoDB:

await usersCollection.updateOne(filter, update);
Aquí, filter es { publicKey: publicKey } para encontrar el documento del usuario, y update
usa el operador $set para modificar solo el campo name

12

13 . MongoDB realizará la actualización de

ese campo y dejará intactos los demás. Según la API del driver, podemos comprobar
result.matchedCount para saber si algún documento coincidió (es decir, la publicKey existía).
Cita: En MongoDB, el método updateOne() acepta primero un objeto de consulta para seleccionar el
documento a modificar, y luego un objeto con los nuevos valores (usualmente usando operadores como
$set ) 12 13 . Por ejemplo, el snippet de más arriba establece el nuevo nombre "NuevoNombre" en el
documento cuyo publicKey coincide. Si esta operación se realiza dentro de una función callback o async/
await como en el ejemplo, puedes manejar errores y enviar la respuesta apropiada.
Por supuesto, en una aplicación real añadiríamos autenticación robusta: idealmente, en cada petición el
usuario debería probar su identidad, ya sea adjuntando una firma como hicimos aquí, o mediante un token
de sesión obtenido tras un login inicial. Lo importante es que el backend confíe en que la petición proviene
del dueño de la cuenta. Gracias a nuestro sistema de claves, podemos lograrlo sin contraseñas
tradicionales.
Otros endpoints y operaciones: De forma similar podrías tener: - GET /user/:publicKey para obtener
el perfil público de un usuario (nombre, bio, seguidores contados, etc.). - POST /follow para que un
usuario siga a otro (actualizar arrays followers y following tanto en el perfil del seguido como del
seguidor). Estas operaciones actualizarían arrays en Mongo ( $push o usando $addToSet para evitar
duplicados). También aquí podrías requerir firmas para evitar que alguien siga a otro en tu nombre
falsamente.
- GET /user/:publicKey/followers para listar seguidores, etc.
Cada operación debería validar la autenticidad (por ejemplo, solo yo puedo cambiar mi perfil o decidir a
quién seguir), ya sea comprobando una firma o un token de autenticación que el usuario obtuvo
previamente firmando una sola vez.
Con esto, tenemos una estructura backend capaz de guardar y servir los datos de los usuarios de manera
consistente. La clave pública enlaza todas las piezas: actúa como ID del usuario en la base de datos y como
la forma de verificar firmas de ese usuario.

4. Redundancia y Recuperación de Datos: Uso de MongoDB + IPFS
Una vez almacenados los datos en MongoDB, debemos pensar en cómo prevenir la pérdida de información
y cómo recuperarla si el backend falla. MongoDB en producción suele desplegarse en replicación (replica
sets) o con backups periódicos, lo cual ya brinda redundancia: si un nodo cae, otro tiene los datos. Sin

7

embargo, dado el objetivo de dar a los usuarios más control y resiliencia, exploraremos una estrategia
complementaria usando IPFS.
¿Qué es IPFS? IPFS (InterPlanetary File System) es un protocolo y red P2P de almacenamiento de archivos y
datos de forma descentralizada. A diferencia de HTTP, donde pides datos a una dirección (servidor)
específica, en IPFS pides datos por su contenido (identificado por un hash único llamado CID) sin importar
quién los tenga 14 . Cualquier nodo que posea el contenido puede servirlo. Esto significa que si subimos un
fichero o JSON a IPFS, obtenemos un CID; cualquier usuario con ese CID puede recuperar el archivo,
siempre que haya alguien (nosotros u otro peer) alojándolo. La ventaja es que no hay un solo punto de falla:
si un servidor central se cae, los datos podrían obtenerse de otros nodos en la red, mejorando la
resiliencia y evitando monopolios de datos 15 .
¿Cómo usar IPFS en Oxy Auth? Podemos utilizar IPFS para respaldar la información clave de cada
usuario (o incluso toda la base de datos periódicamente). Por ejemplo, cada vez que se actualice el perfil de
un usuario, podríamos generar una representación JSON del perfil y guardarla en IPFS. El CID resultante
puede almacenarse en MongoDB como referencia. En caso de pérdida de datos en MongoDB, podríamos
recuperar desde IPFS esos JSON usando los CIDs almacenados.
Pasos sugeridos para integración IPFS:
- Ejecutar un nodo IPFS: Puede ser un nodo local en el servidor backend, o usar un servicio público/pinning
service (como Pinata o Infura) vía sus APIs. Hay librerías como ipfs-http-client para Node.js que te
permiten añadir archivos a IPFS fácilmente.
- Guardar perfil en IPFS al actualizar: Siguiendo el ejemplo anterior de actualizar nombre, después de
updateOne exitoso, podríamos:

const userProfile = await usersCollection.findOne({ publicKey });
const buffer = Buffer.from(JSON.stringify(userProfile));
const cid = await ipfsClient.add(buffer); // ipfsClient.add devuelve un CID
// Guardamos el CID en el perfil, o en una colección de backups
await usersCollection.updateOne({ publicKey }, { $set: { lastProfileCID:
cid.toString() } });
De esta forma, tenemos almacenado el CID que apunta a la versión reciente del perfil. El contenido dentro
de IPFS estará identificado por ese hash de contenido.
• Recuperación desde IPFS: Si la base de datos sufriera una pérdida catastrófica de datos (y
asumiendo que los CIDs se almacenaron en un lugar seguro, o que los usuarios los tienen
apuntados, o se replicaron), podríamos reconstruir la información. Por ejemplo, el usuario al volver a
la app podría enviar su publicKey al servidor. El servidor puede buscar en un registro de
respaldos (o pedir al usuario algún CID de backup que haya guardado). Dado un CID, se hace
ipfsClient.cat(cid) para obtener el JSON del perfil y luego reinsertarlo en MongoDB.
• Ventaja de la firma en backups: Si guardamos en IPFS perfiles firmados por el usuario (por
ejemplo, un JSON que incluya la firma del usuario sobre los datos), cualquiera que recupere ese
perfil puede verificar la firma contra la clave pública. Así, incluso sin confiar en quién almacenó el

8

backup, se puede asegurar la integridad del perfil restaurado. Este enfoque garantiza que la
recuperación no introduzca datos corruptos o falsos.
Un escenario práctico de reindexado desde el cliente: Imagina que el servidor perdió la información de
seguidores de Alice. Alice todavía tiene su lista de seguidos/seguidores localmente (quizá en su app o en
IPFS). Alice podría enviar de nuevo esa información firmada. Por ejemplo, su app puede saber a quién
seguía (porque lo muestra en UI o lo guardó en SecureStore), entonces al detectar inconsistencia, puede
notificar al backend: "estos son mis seguidores/seguidos actuales y lo pruebo con mi firma". El backend
entonces reindexa esos datos. Esta estrategia requiere planificar de antemano qué datos se cachean
localmente o en IPFS.
Importante: IPFS tiene un comportamiento inmutable por contenido: cada vez que un dato cambia, el CID
cambia (porque cambia el hash). Esto significa que un perfil de usuario podría tener muchos CIDs históricos
si se actualiza con frecuencia. Podríamos mantener solo el más reciente en la BD (campo
lastProfileCID como sugerido). Alternativamente, podríamos utilizar IPNS (IPFS Name System) para
tener una dirección fija que siempre apunte al último CID de perfil, pero eso añade complejidad y requiere
mantener la publicación de IPNS.
Limitaciones de IPFS: No es la panacea para datos transaccionales o muy dinámicos debido a su
naturaleza de contenido direccionado (muchos cambios = muchos hashes) 16 . Además, IPFS no garantiza
que los datos se conserven a menos que algún nodo los esté "pinning" (guardando). En nuestro caso,
podríamos comprometernos a que nuestro servidor IPFS (o un servicio externo) conserve esos CIDs.
También, al usar IPFS de esta manera, los datos de perfil podrían ser públicos (a menos que los cifremos
antes de subir). Si la privacidad es crítica, podríamos cifrar el JSON del perfil con una clave derivada de la
privada del usuario antes de almacenarlo en IPFS, de modo que solo el usuario (o amigos autorizados)
puedan leerlo. Esto aumenta la complejidad, por lo que inicialmente podemos no cifrar el perfil en IPFS,
asumiendo que es similar a información pública de redes sociales.
Beneficios de combinar MongoDB + IPFS:
- MongoDB nos da rapidez y flexibilidad para consultar datos (por ejemplo, filtrar usuarios, hacer joins
manuales, etc.) en un entorno centralizado.
- IPFS nos da redundancia descentralizada: si nuestro servidor (o base de datos) falla, los usuarios no
pierden todo ya que sus datos esenciales viven en una red distribuida. Incluso podrían migrar a otro
backend manteniendo su identidad (clave) y recuperando sus datos de IPFS.
- Los usuarios tienen la tranquilidad de que hay un respaldo fuera del control exclusivo de la aplicación,
alineado con darles más derechos y control.
En resumen, para asegurar la integridad del usuario incluso ante fallos graves del backend, combina
backups tradicionales con backups descentralizados. Realiza copias de seguridad periódicas de
MongoDB, pero también aprovecha IPFS para almacenar versiones firmadas de los perfiles u otros datos
críticos. Si ocurre una pérdida, usa la clave pública del usuario como punto de partida: el usuario puede
identificarse (firmando una solicitud de restauración), y tú puedes obtener su último perfil desde IPFS
mediante el CID guardado 17 o solicitándolo al usuario si lo tiene. Gracias a las firmas, sabremos que esos
datos recuperados son legítimos (fueron creados por el usuario original). Esta combinación robusta de
medidas protege la continuidad del ecosistema Oxy Auth.

9

5. Verificación de Firmas de Otros Usuarios (Autenticidad P2P)
Hemos hablado de cómo un usuario firma sus propios datos y cómo el backend verifica esas firmas. Pero
Oxy Auth es social: usuarios interactúan con otros. ¿Cómo verifica, por ejemplo, el dispositivo de Alice que
un mensaje o dato que dice provenir de Bob realmente fue firmado por Bob?
El proceso es muy similar a lo ya descrito, solo que se realiza en el cliente (o potencialmente en el servidor si
actúa como intermediario). Supongamos que Bob sigue a Alice y envía un comentario en el perfil de Alice (o
cualquier mensaje entre usuarios firmado). Alice descargará el comentario y verá una firma y la clave
pública de Bob (o una referencia a ella). Para verificar la firma de Bob, Alice (o la app) hará lo siguiente:
1. Obtener la clave pública de Bob: Esta podría estar en el comentario mismo (por redundancia), pero
lo normal es que el cliente de Alice ya tenga la clave pública de Bob de cuando lo siguió (pudo
obtenerla del servidor en la lista de seguidores, por ejemplo). De cualquier modo, necesitas tener la
publicKey de quien envió el mensaje para verificar su firma.
2. Recalcular/obtener el mensaje original: En algunos protocolos se firma directamente el mensaje
en texto claro; en otros, se firma un hash o una versión canónica del mensaje (p. ej., JSON ordenado).
Es importante saber exactamente qué se firmó. Supongamos que Bob firmó el texto "Hola
Alice" tal cual. Alice tomará ese texto y, usando la misma función hash (SHA-256), obtendrá el
hash del mensaje.
3. Usar un algoritmo de verificación: Dado el hash, la firma y la clave pública de Bob, se ejecuta la
verificación ECDSA. En Node.js, esto se puede hacer con la clase crypto.Verify fácilmente 18 ,
mientras que en React Native podemos usar nuevamente la librería elliptic o alguna función de la
librería utilizada. Con elliptic, si tenemos la instancia ec , haríamos:
const publicKeyPoint = ec.keyFromPublic(bobPublicKeyHex, 'hex');
const msgHash = CryptoJS.SHA256(message).toString(); // por ejemplo usando
CryptoJS en RN
const signature = ... // objeto o formato DER de la firma de Bob
const valid = publicKeyPoint.verify(msgHash, signature);
La función verify devolverá true o false. (CryptoJS lo usamos aquí para el hash solo como
ejemplo; expo-crypto también podría usarse pero es asíncrono. CryptoJS es una librería JS común
para hashing y otras operaciones criptográficas en frontend).
En el backend con Node crypto , sería análogo: crear un verificador, actualizar con el mensaje y usar
verify.verify(publicKey, signature)

18 , obteniendo

true o false .

Si valid === true , Alice puede confiar que Bob realmente escribió ese mensaje y no fue alterado. Si
es false, sabrá que algo anda mal (mensaje corrupto o firmado con otra clave → potencial suplantación).
Intercambio de claves públicas: Para que esto funcione, los usuarios necesitan conocer las claves públicas
de los demás. En Oxy Auth, la forma sencilla es que el servidor actúe como directorio: cuando Alice ve el
perfil de Bob en la app, el servidor le envía la clave pública de Bob (que es parte del perfil). Como esa clave
pública fue registrada por Bob al unirse (y posiblemente verificada si hubo un proceso de firma en registro),
Alice puede asumir que es correcta. También podríamos implementar un modelo más descentralizado de

10

intercambiar claves (por ejemplo, QR codes, DID, etc.), pero inicialmente confiar en el servidor para proveer
la clave pública de cada usuario está bien, siempre y cuando el servidor no sea malicioso. Si se desconfía
incluso del servidor, los usuarios podrían compartir sus claves públicas por canales externos (como se hace
con llaves PGP) pero eso escapa a nuestro alcance.
Uso de verificación en la app: Cada vez que la app reciba datos ajenos importantes (comentarios,
confirmaciones, etc.), debe verificar la firma antes de mostrarlos como "auténticos". Si la verificación falla,
podría marcar ese contenido como no confiable o alertar al usuario. En muchos casos, si los datos vienen
del servidor de Oxy Auth, este ya podría haber filtrado los no válidos (verificando antes de difundirlos). Aun
así, el cliente final tiene la potestad de verificar por sí mismo para máxima seguridad.
Con esto, conseguimos un ecosistema de confianza distribuida: cualquier entidad con la clave pública de
un usuario puede verificar cualquier cosa firmada por ese usuario. No necesita consultar a un servidor
central para preguntar "¿esto es válido?" – la criptografía lo valida. Por eso es crucial mantener las claves
públicas correctas; incluso un atacante que invente un usuario no puede falsificar la firma de otro.

6. División de Tareas: ¿Qué ocurre en el Frontend vs Backend?
Recapitulando las partes críticas del sistema, dejemos claro qué lógica va en la app móvil (frontend) y cuál
en el servidor (backend), así como las bibliotecas adecuadas en cada contexto:
• Frontend (Expo React Native):
• Generación de identidad (claves): se realiza en el dispositivo. Usamos librerías JS como elliptic
para ECDSA o react-native-rsa si quisiéramos RSA (requiere un módulo nativo) 19 . Dado que
Expo 54 soporta agregar módulos nativos mediante config-plugins, se podría usar react-nativersa-native

20

para generar claves RSA de forma más sencilla, pero preferimos ECDSA por

eficiencia. Otra opción moderna es usar la Web Crypto API a través de crypto.subtle si
estuviera disponible en React Native (no lo está por defecto en todas las engines, pero en desarrollo
futuro quizá). En la web, crypto.subtle.generateKey puede generar par ECDSA 21 , pero en
React Native es más seguro usar librerías dedicadas como las mencionadas.
• Almacenamiento de clave privada: Expo SecureStore (integrado en Expo) para guardar de forma
segura la clave privada 7 . Adicionalmente, podría usarse react-native-keychain para
almacenar credenciales en el llavero de iOS/Android, pero en apps Expo Managed, SecureStore es la
opción más directa.
• Firmas de datos: Se realizan en el dispositivo con la clave privada. Bibliotecas como expo-crypto
proporcionan hashing (SHA-256, etc.)

3

, y combinada con elliptic o tweetnacl (si usáramos

Ed25519) podemos producir firmas. crypto-js es otra librería popular para hashing y cifrado en
JS que funciona en React Native; por ejemplo, para obtener un SHA-256 o para cifrar datos
simétricamente. En nuestro caso, crypto-js podría complementar expo-crypto si necesitáramos
funcionalidades no cubiertas (como HMAC, cifrado AES, etc.).
• Verificación de firmas: El cliente también puede verificar firmas de otros, para lo cual puede reutilizar
las mismas librerías ( elliptic puede verificar ECDSA fácilmente como vimos, tweetnacl tiene
nacl.sign.detached.verify para Ed25519, etc.). Esto permite que la app valide autenticidad de
datos recibidos sin depender de terceros.
• Interfaz y lógica de presentación: Expo/React Native manejará mostrar el perfil, lista de seguidores,
permitir editar perfil, etc., llamando a la API del backend y procesando los resultados. Antes de

11

enviar datos sensibles al backend, la app los firmará; y tras recibir respuestas, verificará firmas si es
necesario.
• Backend (Node.js + MongoDB):
• Almacenamiento central: MongoDB almacena todos los perfiles de usuarios, sus relaciones de
seguimiento, posts/mensajes si los hubiera, etc. Actúa como la “fuente de verdad” accesible para
consultas globales (por ejemplo, para listar quiénes son los seguidores de X, es más fácil que cada
cliente tuviera que conocerlo).
• API REST/GraphQL: Implementada en Node (con Express u otro framework) para que las apps clientes
puedan registrar usuarios, obtener perfiles, seguir usuarios, etc.
• Verificación de autenticidad: El servidor, al recibir peticiones con firma (como en la actualización de
nombre), usará la clave pública almacenada para verificar. Node.js incluye el módulo crypto que
soporta ECDSA mediante crypto.createVerify y crypto.verify fácilmente 18 . Por
ejemplo:
const verify = crypto.createVerify('SHA256');
verify.update(message);
verify.end();
const isValid = verify.verify(userPublicKeyPem, signatureHex, 'hex');
Donde userPublicKeyPem sería la clave pública en formato PEM (si la almacenamos en hex,
debemos convertirla a un KeyObject o PEM para esta función). Si no, podríamos usar también
elliptic en Node para verificar de igual manera que en el cliente.
• Manejo de datos y lógica de negocio: El backend asegurará consistencia (por ejemplo, si A sigue a B,
incrementa el contador de seguidores de B, etc.), aplicará controles de acceso (solo yo puedo
cambiar mi perfil), y agregará seguridad extra (rate limiting, sanitización de inputs para evitar
inyección, etc.).
• Integración con IPFS: El servidor puede ejecutar un nodo IPFS o conectarse a uno remoto. Tras
operaciones de actualización, puede serializar ciertos datos y enviarlos a IPFS (como describimos).
También en caso de recuperación de desastre, el backend orquestará la restauración desde IPFS. La
biblioteca ipfs-http-client (oficial de IPFS) puede ser utilizada en Node para estas tareas con
métodos como add (añadir y obtener CID) y cat (recuperar por CID).
• Bibliotecas adicionales en backend: Para interactuar con MongoDB usamos el MongoDB Node
Driver o Mongoose (este último facilita la definición de esquemas y validación). Para nuestro
ejemplo directo usamos el driver básico con updateOne y similares 12 13 . También podríamos
usar jsonwebtoken si quisiéramos crear tokens JWT firmados por el servidor para sesiones (aunque
la autenticación principal es por firma del usuario, a veces es útil emitir un JWT después del login
para no firmar cada solicitud). Dado el enfoque descentralizado, se podría omitir JWT y siempre
requerir firmas en las operaciones críticas; es un diseño posible en sistemas "trustless", aunque para
eficiencia muchos sistemas combinan: firma inicial para login, luego token para no firmar todo el
tiempo cada clic.

12

7. Ejemplo concreto: Actualizar el nombre de usuario (Código en
Node.js + MongoDB)
Para consolidar ideas, retomemos el ejemplo clave solicitado: actualizar el nombre de usuario. A
continuación se muestra un fragmento de código autónomo que podría formar parte del backend. Utiliza
Node.js y el driver de MongoDB para cambiar el nombre de un usuario identificado por su clave pública.
También se incluye la verificación de firma por seguridad:

// Dependencias necesarias
const { MongoClient } = require('mongodb');
const crypto = require('crypto'); // módulo nativo de Node.js para funciones
cripto
// Suponemos que ya nos conectamos a MongoDB y tenemos la colección
const usersCollection = db.collection('users');
// Función para verificar firma ECDSA (usando la API de Node crypto)
function verifySignature(publicKeyHex, message, signatureHex) {
// Para usar crypto.verify, necesitamos la clave pública en formato PEM
// Construimos un PEM simple asumiendo publicKeyHex es un punto uncompressed
(04 + X + Y en hex)
const publicKeyDer =
Buffer.from('3056301006072a8648ce3d020106052b8104000a034200' + publicKeyHex,
'hex');
const publicKeyPem = `-----BEGIN PUBLIC KEY-----\n$
{publicKeyDer.toString('base64')}\n-----END PUBLIC KEY-----\n`;
const verify = crypto.createVerify('SHA256');
verify.update(message);
verify.end();
return verify.verify(publicKeyPem, Buffer.from(signatureHex, 'hex'));
}
// Función para actualizar nombre
async function updateUserName(userPublicKey, newName, signatureHex) {
// Verificar que la firma del usuario sobre el nuevo nombre es válida
const message = `name:${newName}`; // el mensaje que el usuario debía firmar
const isAuthentic = verifySignature(userPublicKey, message, signatureHex);
if (!isAuthentic) {
throw new Error('Firma inválida: no se puede autenticar al usuario');
}
// Actualizar en la base de datos
const filter = { publicKey: userPublicKey };
const update = { $set: { name: newName } };
const result = await usersCollection.updateOne(filter, update);

13

if (result.modifiedCount === 1) {
console.log(`Nombre del usuario (${userPublicKey}) actualizado a "$
{newName}"`);
} else {
console.log(`No se encontró usuario con clave ${userPublicKey}`);
}
}
Explicación:
- La función verifySignature toma la clave pública en hex, el mensaje original y la firma en hex, y utiliza
crypto.verify de Node para comprobar la firma ECDSA SHA256 18 . Tuvimos que envolver la clave
pública en formato PEM para usar esta API (esto implica ciertos bytes DER al inicio que especifican la curva;
el ejemplo concatena un encabezado fijo para secp256k1). En un caso real, podríamos almacenar
directamente la clave pública en PEM en la BD para simplificar, o usar otra librería de verificación.
- Luego updateUserName usa esa función para asegurarse de que la petición es legítima. Si lo es, procede
a hacer updateOne en Mongo tal como antes, usando $set: { name: newName }

13 . - Dependiendo

de la estructura, podríamos enviar un mensaje de éxito al cliente o manejar el error apropiadamente.
Este ejemplo demuestra end-to-end la acción de actualizar un campo del usuario de forma segura: la app
habría llamado a esta función del servidor pasando la firma del usuario; el servidor verifica con la clave
pública de su base de datos y actualiza MongoDB. Todo el proceso garantiza que solo el usuario dueño de
la cuenta pudo haber solicitado el cambio.

Conclusiones y Consideraciones Finales
Siguiendo estos pasos, hemos construido un sistema de autenticación y perfil de usuario que otorga al
individuo un mayor control, privacidad y seguridad sobre sus datos, cumpliendo con la visión de Oxy
Auth. Repasemos los logros y cómo encajan en un ecosistema más amplio de identidad distribuida:
• Identidad auto-custodiada: Cada usuario controla su par de claves. No dependemos de un
proveedor central para la autenticación (como Google/Facebook), ni almacenamos contraseñas. La
identidad es tan fuerte como la clave privada del usuario; si la mantiene segura, nadie puede
hacerse pasar por él. Esto empodera al usuario y elimina ciertos vectores de ataque (por ejemplo,
brechas de contraseñas en el servidor).
• Firmas digitales para autenticidad: Todas las acciones críticas se firman. Esto asegura integridad
de los datos y no repudio (un usuario no puede negar una acción que firmó, y un atacante no puede
falsificarla). Hemos aplicado principios similares a los de blockchain en una aplicación convencional:
confianza mediante criptografía, no solo mediante credenciales o sesiones.
• Datos en MongoDB con enfoque seguro: Aunque usamos una base de datos tradicional, lo
hacemos cuidadosamente. Clave pública como identificador, datos personales limitados y con
posibilidad de verificación. Aplicamos buenas prácticas de actualización (como $set para modificar
campos específicos 22 ) y podríamos extender con validaciones de esquema (por ejemplo, usando
Mongoose schemas para tipos de datos y formatos esperados).
• Redundancia y descentralización con IPFS: Introdujimos un componente descentralizado de
almacenamiento. Así, los datos no viven únicamente en una base de datos controlada por una
entidad; también pueden vivir distribuidos en una red P2P. Esto protege contra pérdida de datos y

14

potencialmente contra censura o bloqueos, ya que los usuarios (o terceros) podrían recuperar
información sin depender del servidor original 15 . Además, este modelo permite imaginar
interoperabilidad: si mañana otro servicio quiere integrarse, podría (con permiso) leer ciertos datos
desde IPFS o verificar identidades por las claves públicas, fomentando un ecosistema más abierto.
• Privacidad y control: Los usuarios pueden tener mayor privacidad porque, por ejemplo, podríamos
permitir que algunos datos se almacenen cifrados con su clave pública en el servidor, y solo
descifren localmente con su privada (ej: mensajes privados, si la app tuviera mensajería). También,
como mencionamos, respaldos en IPFS podrían cifrarse con una contraseña del usuario para que
solo él los restaure. Todo esto devuelve la agencia al usuario sobre quién puede ver sus datos. En
nuestro diseño actual, los datos de perfil básico no están cifrados (similar a una red social pública),
pero el marco sentado permite añadir capa de cifrado si se quisiera (por ejemplo, campo bio
cifrado en DB y IPFS, y solo visible para quien tenga la clave). La clave privada del usuario podría
derivar otras claves de cifrado si quisiéramos sofisticación (similar a como una wallet HD deriva
múltiples claves).
Ecosistema de usuarios empoderados: Con Oxy Auth, imaginemos un futuro donde varias aplicaciones
reconocen la identidad de los usuarios por su clave pública. Un usuario podría portar su reputación,
seguidores, etc., entre plataformas, porque su identidad ya no es silo de una empresa sino algo que él
posee. Esto se alinea con movimientos de identidad descentralizada (DID) y Web3, aunque nuestra
implementación usa tecnologías estándar (React Native, Node.js, MongoDB) para lograr objetivos similares:
autenticación descentralizada y datos bajo control del usuario.
Siguiente pasos y recomendaciones:
- Implementar recuperación de cuenta por parte del usuario en caso de cambiar de dispositivo: dado que la
clave privada reside solo en el dispositivo, si lo pierde sin respaldo, pierde acceso a su cuenta. Para mitigar
esto, podrías ofrecer al usuario exportar una frase de recuperación (como las 12 palabras tipo billetera de
criptomonedas) que represente su clave privada. Así, podría reinstaurarla en un nuevo dispositivo. Esto
debe explicarse claramente al usuario (responsabilidad de guardar su backup) y protegerse con cifrado si se
almacena en alguna nube.
- Considerar una capa de DID (Decentralized Identifier): estándares como DID + DID Documents podrían
formalizar cómo se comparte la clave pública y demás meta-datos de identidad, permitiendo interoperar
con otras plataformas fácilmente.
- Mejorar la eficiencia de firmas/verificaciones: actualmente firmar cada solicitud puede ser costoso; podrías
introducir sesiones temporales (ej. un token JWT que expire en 1 hora, firmado por el servidor tras verificar
la firma inicial del usuario). Así combinas seguridad con rendimiento, sin sacrificar el modelo de no tener
contraseñas.
- Monitorear seguridad de las bibliotecas: usar fuentes confiables (las librerías mencionadas son populares,
pero siempre estar al tanto de actualizaciones). ECDSA secp256k1 es robusto, pero asegúrate de usar buen
generador aleatorio (Expo Random usa CSPRNG).
- Escalabilidad: MongoDB maneja bien muchos documentos, pero la verificación de firmas es
computacional. Sin embargo, el costo es manejable (verificar ECDSA es rápido, y podría incluso hacerse
asíncronamente o en un worker thread si hubiera altísima carga). IPFS añade latencia para respaldos;
podrías hacer que esas operaciones sean en segundo plano (por ejemplo, actualizar Mongo
inmediatamente y en background subir a IPFS).
Con todo esto, has construido una aplicación móvil con un modelo de autenticación moderno y centrado en
el usuario. Los usuarios de Oxy Auth disfrutan de más derechos, privacidad y control: su identidad no
puede ser robada del servidor, sus datos tienen respaldo y pueden moverse, y sus interacciones están

15

firmadas y verificables. Esta guía te brinda las bases técnicas para lograrlo, combinando las herramientas
de desarrollo móvil y web tradicionales con conceptos de blockchain/cripto para crear una experiencia más
segura y descentralizada para todos.
Fuentes consultadas: La implementación de claves y firmas se inspira en prácticas de Bitcoin y criptografía
moderna 1 2 . Se usaron referencias de la librería elliptic para generación de claves secp256k1 4 ,
recordando no exponer las privadas 6 . Expo SecureStore es recomendada para almacenar secretos en
dispositivos móviles 7 . IPFS se explicó según su filosofía de direccionamiento por contenido y ventajas de
descentralización 14 15 , integrándolo como redundancia en nuestro sistema. Para las operaciones en
MongoDB, se ilustró el uso de updateOne con $set 13 . Finalmente, la verificación de firmas en Node
se basó en los métodos nativos de la API de crypto 18 para ECDSA SHA-256. Con estos componentes
combinados, Oxy Auth está técnicamente fundamentado para cumplir su promesa de una autenticación
segura y user-centric en la era de la soberanía de datos. 3 10

1

ECDSA | Elliptic Curve Digital Signature Algorithm

https://learnmeabitcoin.com/technical/cryptography/elliptic-curve/ecdsa/

Bitcoin Signatures From Scratch (3/4): Using The Magic of Elliptic Curves to Sign and Verify Messages
- DEV Community
2

11

https://dev.to/exemak/bitcoin-signatures-from-scratch-34-using-the-magic-of-elliptic-curves-to-sign-and-verify-messages-41i2
3

Crypto - Expo Documentation

https://docs.expo.dev/versions/latest/sdk/crypto/
4

5

6

8

Generate Keypair using secp256k1 in JavaScript | SSOJet

https://ssojet.com/keypair-generation/generate-keypair-using-secp256k1-in-javascript/
7

SecureStore - Expo Documentation

https://docs.expo.dev/versions/latest/sdk/securestore/
9

10

21

Understanding and Implementing ECDSA in Javascript Cryptography

https://www.haikel-fazzani.eu.org/blog/post/javascript-cryptography-ecdsa
12

13

22

Node.js MongoDB Update

https://www.w3schools.com/nodejs/nodejs_mongodb_update.asp
14

15

17

Breaking the chains: Exploring the decentralized power of IPFS - ManageEngine Blog

https://www.manageengine.com/blog/general/breaking-the-chains-exploring-the-decentralized-power-of-ipfs.html
16

Integrated IPFS | Elastos Wiki

https://elastos-wiki.netlify.app/learn/hive/features/ipfs/
18

cryptography - How to create ECDSA signature with Node.js crypto? - Stack Overflow

https://stackoverflow.com/questions/73079051/how-to-create-ecdsa-signature-with-node-js-crypto
19

20

How to generate Digital Signatures in React Native | by Advyth Ashok | Medium

https://medium.com/@advythashok/how-to-generate-digital-signatures-in-react-native-77026f2787e

16

